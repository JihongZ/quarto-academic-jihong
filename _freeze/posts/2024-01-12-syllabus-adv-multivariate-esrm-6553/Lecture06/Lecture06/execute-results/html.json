{
  "hash": "e2d5640d286dfcf91112a4cb6021a586",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 06\"\nsubtitle: \"Generalized Measurement Models: An Introduction\"\nauthor: \"Jihong Zhang\"\ninstitute: \"Educational Statistics and Research Methods\"\ntitle-slide-attributes:\n  data-background-image: ../Images/title_image.png\n  data-background-size: contain\n  data-background-opacity: \"0.9\"\nexecute: \n  echo: true\nformat: \n  revealjs:\n    logo: ../Images/UA_Logo_Horizontal.png\n    incremental: true  # choose \"false \"if want to show all together\n    theme: [serif, ../pp.scss]\n    footer:  <https://jihongzhang.org/posts/2024-01-12-syllabus-adv-multivariate-esrm-6553>\n    transition: slide\n    background-transition: fade\n    slide-number: true\n    chalkboard: true\n    number-sections: false\n    code-line-numbers: true\n    code-link: true\n    code-annotations: hover\n    code-copy: true\n    highlight-style: arrow\n    code-block-border-left: true\n    code-block-background: \"#b22222\"\n    mermaid:\n      theme: neutral\n#bibliography: references.bib\n---\n\n\n## Today's Lecture Objectives\n\n1.  Introduce measurement (psychometric) models in general\n\n2.  Describe the steps needed in a psychometric model analysis\n\n3.  Dive deeper into the observed-variables modeling aspect\n\n# Measurement Model in general\n\n## Measurement Model Analysis Steps\n\n\n```{mermaid}\n%%| echo: false\n%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\ngraph TD\nsubgraph \"Measurement Procedure\"\n  subgraph Modeling\n  direction LR\n  Start --> id1\n  id1([Specify model]) --> id2([\"`Specify scale identification \n  method for latent variables`\"])\n  id2 --> id3([Estimate model])\n  id3 --> id4{Adequate fit indices}\n  id4 -- No --> id1\n  end\n  Modeling -- Model fit acceptable --> one\n  subgraph one[\"Evaluation: Measurement Model with Auxiliary Components\"]\n    direction LR\n    id5([\"Score estimation \n    and secondary analyses with scores\"]) --> id6([Item evaluation])\n    id6 --> id7([Scale construction])\n    id7 --> id8([Equating])\n    id8 --> id9([Measure Invariance/Differential item functioning])\n    id9 --> End\n  end\nend\nstyle Start fill:#f9f,stroke:#333,stroke-width:5px\nstyle End fill:#bbf,stroke:#333,stroke-width:5px\n```\n\n\n## Components of a Measurement Model\n\nThere are two components of a measurement model\n\n**Theory (what we cannot see but assume its existence):**\n\n::: nonincremental\n-   Latent variable(s)\n\n-   Other effects as needed by a model\n\n    ::: nonincremental\n    -   Random effects (e.g., initial status and slopes in Latent Growth Model)\n\n    -   Testlet effects (e.g., a group-level variation among items)\n\n    -   Effects of observed variables (e.g., gender differences, DIF, Measurement Invariance)\n    :::\n:::\n\n**Data (what we can see and we assume generated by theory):**\n\n::: nonincremental\n-   Outcomes\n\n    -   An assumed distribution for each outcome\n\n    -   A key statistic of outcome for the model (e.g., mean, sd)\n\n    -   A link function\n:::\n\n------------------------------------------------------------------------\n\n### General form for measurement model (SEM, IRT):\n\n$$\nf(E(\\mathbf{Y}\\mid\\Theta)) = \\boldsymbol{\\mu} +\\Theta\\Lambda^T\n$$\n\nand\n\n$$\n\\Lambda_j = Q \\odot \\boldsymbol{\\lambda_j}\n$$\n\nAssume N as sample size, P as number of factors, J as number of items. Then,\n\n::: nonincremental\n-   $f()$: link function. CFA: identity link; IRT: logistic/probit link\n-   $E(\\mathbf{Y}\\mid\\Theta)$: Expected/Predicted values of outcomes\n-   $\\Theta$: latent factor scores matrix (N $\\times$ P)\n-   $\\Lambda$: A factor loading matrix (J $\\times$ P)\n    -   $\\Lambda_j$: $j$th row vector of factor loading matrix\n\n    -   $\\textbf{Q}$: Q-matrix represents the connections between items and latent variables\n\n    -   $\\boldsymbol{\\lambda}_j$: a vector of factor loading vectors for item $j$\n-   $\\mu$: item intercepts (J $\\times$ 1)\n:::\n\n------------------------------------------------------------------------\n\n### Example 1 with general form\n\n::: columns\n::: {.column width=\"70%\"}\nLet's consider a measurement model with only one latent variable and five items:\n\n\n```{mermaid}\n%%| echo: false\n%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\nflowchart TD\n  id1((θ)) --> id2[\"Y1\"]\n  id1 --> id3[\"Y2\"]\n  id1 --> id4[\"Y3\"]\n  id1 --> id5[\"Y4\"]\n  id1 --> id6[\"Y5\"]\n```\n\n\nThe model shows:\n\n::: nonincremental\n-   One latent variable ($\\theta$)\n\n-   Five observed variables ($\\mathbf{Y} = \\{Y_1, Y_2, Y_3, Y_4, Y_5\\}$)\n:::\n:::\n\n::: {.column width=\"30%\"}\nThen,\n\n-   $\\Theta$ = $\\begin{bmatrix} \\theta_1, \\\\\\theta_2,\\\\ \\cdots,\\\\ \\theta_N \\end{bmatrix}$\n\n-   $\\Lambda^T$ = $\\begin{bmatrix}\\lambda_1, \\lambda_2, ..., \\lambda_5 \\end{bmatrix}$\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Example 2 with general form\n\n::: columns\n::: {.column width=\"70%\"}\nLet's consider a measurement model with only two latent variables and five items:\n\n\n```{mermaid}\n%%| echo: false\n%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\nflowchart TD\n  theta1((θ1)) --> id2[\"Y1\"]\n  theta1 --> id3[\"Y2\"]\n  theta1 --> id4[\"Y3\"]\n  theta1 --> id5[\"Y4\"]\n  theta1 --> id6[\"Y5\"]\n  theta2((θ2)) --> id2[\"Y1\"]\n  theta2 --> id3[\"Y2\"]\n  theta2 --> id4[\"Y3\"]\n  theta2 --> id5[\"Y4\"]\n  theta2 --> id6[\"Y5\"]\n```\n\n\nThe model shows:\n\n::: nonincremental\n-   Two latent variables ($\\theta_1$, $\\theta_2$)\n\n-   Five observed variables ($\\mathbf{Y} = \\{Y_1, Y_2, Y_3, Y_4, Y_5\\}$)\n:::\n:::\n\n::: {.column width=\"30%\"}\nThen,\n\n-   $\\Theta$ = $\\begin{bmatrix} \\theta_{1,1}, \\theta_{1,2}\\\\\\theta_{2,1}, \\theta_{2,2}\\\\ \\cdots,\\cdots \\\\ \\theta_{N, 1}, \\theta_{N,2} \\end{bmatrix}$ $\\sim [0, \\Sigma]$\n\n-   $\\Lambda^T$ = $\\begin{bmatrix}\\lambda_{1,1}, \\lambda_{1,2}, ..., \\lambda_{1,5}\\\\\\lambda_{2,1}, \\lambda_{2,2}, ..., \\lambda_{2,5}\\end{bmatrix}$\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Example 3 with general form\n\n::: columns\n::: {.column width=\"70%\"}\nLet's consider a measurement model with only two latent variables and five items:\n\n\n```{mermaid}\n%%| echo: false\n%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\nflowchart TD\n  theta1((θ1)) --> id2[\"Y1\"]\n  theta1 --> id3[\"Y2\"]\n  theta1 --> id4[\"Y3\"]\n  theta2((θ2)) --> id4[\"Y3\"]\n  theta2 --> id5[\"Y4\"]\n  theta2 --> id6[\"Y5\"]\n```\n\n\nThe model shows:\n\n::: nonincremental\n-   Two latent variables ($\\theta_1$, $\\theta_2$)\n\n-   Five observed variables ($\\mathbf{Y} = \\{Y_1, Y_2, Y_3, Y_4, Y_5\\}$)\n:::\n:::\n\n::: {.column width=\"30%\"}\nThen,\n\n-   $\\Theta$ = $\\begin{bmatrix} \\theta_{1,1}, \\theta_{1,2}\\\\\\theta_{2,1}, \\theta_{2,2}\\\\ \\cdots,\\cdots \\\\ \\theta_{N, 1}, \\theta_{N,2} \\end{bmatrix}$ $\\sim [0, \\Sigma]$\n\n-   $\\Lambda^T$ = $\\begin{bmatrix}\\lambda_{1,1}, \\lambda_{1,2}, \\lambda_{1,3}, 0,0\\\\ 0, 0, \\lambda_{2,3}, \\lambda_{2,4}, \\lambda_{2,5}\\end{bmatrix}$\n\n-   Note that we only limit our model to main-effect models. Interaction effects of factors introduce more complexity.\n\n-   It is difficulty to specify factor loadings with $0$s directly\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Item-specific form\n\nFor each item j:\n\n$$\n\\mathbf{Y_j} \\sim N(\\mu_j+ \\boldsymbol{\\lambda}_{j}Q_j\\Theta, \\psi_j)\n$$\n\n## Bayesian view: latent variables\n\nLatent variables in Bayesian are built by following specification:\n\n1.  What are their distributions? (normal distribution or others)\n\n    -   For example, $\\theta_i$ values for one person and $\\theta$ values for samples. Factor score $\\theta$ is a mixture distribution of distributions of each individual's factor score $\\theta_i$\n\n    -   But, in MLE/WSLMV, we do not estimate mean and sd of each individual's factor score for model to be converged\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(tidyverse)\nset.seed(12)\nN = 15\nndraws = 200\nFS = matrix(NA, nrow = N, ndraws)\nFS_p = rnorm(N)\nFS_p = FS_p[order(FS_p)]\nfor (i in 1:N) {\n  FS[i,] = rnorm(ndraws, mean = FS_p[i], sd = 1)\n}\nFS_plot <- as.data.frame(t(FS))\ncolnames(FS_plot) <- paste0(\"Person\", 1:N)\nFS_plot <- FS_plot |> pivot_longer(everything(), names_to = \"Person\", values_to = \"Factor Score\")\nFS_plot$Person <- factor(FS_plot$Person, levels = paste0(\"Person\", 1:N))\nggplot() +\n  geom_density(aes(x = `Factor Score`, fill = Person, col = Person ), alpha = .5, data = FS_plot)  +\n  geom_density(aes(x = FS_p))\n```\n\n::: {.cell-output-display}\n![](Lecture06_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n2.  Multidimensionality\n    -   How many factors to be measured?\n    -   If $\\geq$ 2 factors, we specify mean vectors and variance-covariance matrix\n    -   To link latent variables with observed variables, we need to create a indicator matrix of coefficient/effects of latent variable on items.\n        -   In diagnostic modeling and multidimensional IRT, we call it Q-matrix\n\n## Simulation Study 1\n\n-   Let's perform a small simulation study to see how to perform factor analysis in naive Stan.\n-   The model specification is a two-factor with each measured by 3 items. In total, there are 6 items with continuous responses. Sample size is 1000.\n\n![Model Specification](simulation_model1.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Data Simulation\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(Y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]        [,2]       [,3]       [,4]        [,5]       [,6]\n[1,] -1.0136367 -0.50699773 -0.2803124  0.5407292 -0.37811988 -0.2033511\n[2,]  0.0508203  0.62021463  0.1737470 -1.9893740 -1.23623703 -0.8609000\n[3,]  0.5446843  0.52674674 -0.1523788  0.8198787  0.53021452  0.3435667\n[4,] -0.2721033 -0.08877619  0.2124482 -0.5066111 -0.19928765  0.7955025\n[5,] -0.7291450 -0.15306919 -0.5626197 -0.5083901 -0.07438493 -0.9338468\n[6,] -0.5210657  0.50114831 -0.3317205 -1.0916717 -0.28489250 -0.4464051\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### Strategies for Stan: factor loadings\n\n::: nonincremental\n-   We will iterate over item response function across each item\n-   To benefit from the efficiency of vectorization, we specify a vector of factor loadings with length 6\n    -   $\\{\\lambda_1, \\lambda_2, \\cdots, \\lambda_6 \\}$\n\n    -   Optionally, a matrix with number of items by number of factor for $\\lambda$s can be specified like $\\lambda_{11}$ and $\\lambda_{62}$, that introduces flexibility but complexity\n-   We should have a location table telling `stan` the information about which factor each factor loading belong to\n    -   For example, $\\lambda_{1}$ belongs to factor 1 and $\\lambda_4$ belong to factor 2\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Item Theta q\n[1,]    1     1 1\n[2,]    2     1 1\n[3,]    3     1 1\n[4,]    4     2 1\n[5,]    5     2 1\n[6,]    6     2 1\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### Strategies for Stan: prior distribution and hyperparameters\n\n::: columns\n::: {.column width=\"80%\"}\n::: incremental\n-   residual variances for items: $\\sigma \\sim \\text{exponential}(sigmaRate)$\n    -   sigmaRate is set to 1\n-   item intercepts: $\\mu \\sim \\text{MVN}(meanMu, covMu)$\n    -   meanMu is set to a vector of 0s with length 6\n\n    -   covMu is set to a diagonol matrix of 1000 with 6 $\\times$ 6\n-   factor scores: $\\Theta \\sim \\text{MVN}(meanTheta, corrTheta)$\n    -   meanTheta is set to a vector of 0s with length 2\n\n    -   $corrTheta \\sim lkj\\_corr(eta)$ and eta is set to 1\n\n    -   Optionally, $L \\sim lkj\\_corr\\_cholesky(eta)$ and corrTheta = LL'\n-   factor loadings: $\\Lambda \\sim \\text{MVN}(meanLambda, covLambda)$\n    -   meanLambda is set to a vector of 0s with length 6 (number of items)\n\n    -   covLambdais set to a matrix of $\\begin{pmatrix}1000, 0,\\cdots,0\\\\ \\cdots\\\\0, 0, \\cdots1000\\end{pmatrix}$\n:::\n:::\n\n::: {.column width=\"20%\"}\n-   **Question: what about factor correlation** $\\psi$?\n\n-   See [this blog](http://stla.github.io/stlapblog/posts/StanLKJprior.html) and [Stan's reference](https://mc-stan.org/docs/functions-reference/cholesky-lkj-correlation-distribution.html) for Choleskey decomposition\n\n-   For eta = 1, the distribution is uniform over the space of all correlation matrices\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Data Structure and Data Block\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell filename='Lecture06.R'}\n\n```{.r .cell-code}\ndata_list <- list(\n  N = 1000, # number of subjects/observations\n  J = J, # number of items\n  K = 2, # number of latent variables,\n  Y = Y,\n  Q = Q,\n  # location/index of lambda\n  kk = loc[,2],\n  #hyperparameter\n  sigmaRate = .01,\n  meanMu = rep(0, J),\n  covMu = diag(1000, J),\n  meanTheta = rep(0, 2),\n  eta = 1,\n  meanLambda = rep(0, J),\n  covLambda = diag(1000, J)\n)\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell filename='simulation_loc.stan' output.var='display'}\n\n```{.stan .cell-code}\ndata {\n  int<lower=0> N; // number of observations\n  int<lower=0> J; // number of items\n  int<lower=0> K; // number of latent variables\n  matrix[N, J] Y; // item responses\n  \n  //location/index of lambda\n  array[J] int<lower=0> kk;\n  \n  //hyperparameter\n  real<lower=0> sigmaRate;\n  vector[J] meanMu;\n  matrix[J, J] covMu;      // prior covariance matrix for coefficients\n  vector[K] meanTheta;\n  \n  vector[J] meanLambda;\n  matrix[J, J] covLambda;      // prior covariance matrix for coefficients\n  \n  real<lower=0> eta; // LKJ shape parameters\n}\n```\n:::\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Parameter and Transformed Parameter block\n\n\n::: {.cell filename='simulation_loc.stan' output.var='display'}\n\n```{.stan .cell-code}\nparameters {\n  vector[J] mu;                      // item intercepts\n  vector<lower=0,upper=1>[J] lambda; // factor loadings\n  vector<lower=0>[J] sigma;          // the unique residual standard deviation for each item\n  matrix[N, K] theta;                // the latent variables (one for each person)\n  cholesky_factor_corr[K] L;         // L of factor correlation matrix\n}\ntransformed parameters{\n  matrix[K,K] corrTheta = multiply_lower_tri_self_transpose(L);\n}\n```\n:::\n\n\nNote that `L` is the Cholesky decomposition factor of factor correlation matrix\n\n::: nonincremental\n-   It is also a lower triangle matrix\n-   use `cholesky_factor_corr[K]` to declare this parameter\n-   Sometime, parameters are those that are easy to sampling, `transformed parameters` block is used to transform your parameters to those that are difficulty to direct sampling.\n:::\n\n------------------------------------------------------------------------\n\n### Model block\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell filename='Lecture06.R'}\n\n```{.r .cell-code}\ndata_list <- list(\n  N = 1000, # number of subjects/observations\n  J = J, # number of items\n  K = 2, # number of latent variables,\n  Y = Y,\n  Q = Q,\n  # location/index of lambda\n  kk = loc[,2],\n  #hyperparameter\n  sigmaRate = .01,\n  meanMu = rep(0, J),\n  covMu = diag(1000, J),\n  meanTheta = rep(0, 2),\n  eta = 1,\n  meanLambda = rep(0, J),\n  covLambda = diag(1000, J)\n)\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell filename='simulation_loc.stan' output.var='display'}\n\n```{.stan .cell-code}\nmodel {\n  mu ~ multi_normal(meanMu, covMu);\n  sigma ~ exponential(sigmaRate);   \n  lambda ~ multi_normal(meanLambda, covLambda);\n  L ~ lkj_corr_cholesky(eta);\n  for (i in 1:N) {\n    theta[i,] ~ multi_normal(meanTheta, corrTheta);\n  }\n  for (j in 1:J) { // loop over each item response function\n    Y[,j] ~ normal(mu[j]+lambda[j]*theta[,kk[j]], sigma[j]);\n  }\n}\n```\n:::\n\n:::\n:::\n\nNote that `kk[j]` selects which factor to be multiplied dependent on factor loading's index. That why we have a location matrix of factor loadings. `Theta` in `loc` table is kk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Item Theta q\n[1,]    1     1 1\n[2,]    2     1 1\n[3,]    3     1 1\n[4,]    4     2 1\n[5,]    5     2 1\n[6,]    6     2 1\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### Generated quantities block\n\n\n::: {.cell filename='simulation_loc.stan' output.var='display'}\n\n```{.stan .cell-code}\ngenerated quantities {\n  vector[N * J] log_lik;\n  matrix[N, J] temp;\n  matrix[N, J] Y_rep;\n  vector[J] Item_Mean_rep;\n  for (i in 1:N) {\n    for (j in 1:J) {\n      temp[i, j] = normal_lpdf(Y[i, j] | mu[j]+lambda[j]*theta[i,kk[j]],  sigma[j]); \n    }\n  }\n  log_lik = to_vector(temp);\n  for (j in 1:J) {\n    Y_rep[,j] = to_vector(normal_rng(mu[j]+lambda[j]*theta[,kk[j]], sigma[j]));\n    Item_Mean_rep[j] = mean(Y_rep[,j]);\n  }\n}\n\n```\n:::\n\n\nTo obtain leave-one-out (LOO) model fitting, we need to generate log-likelihood:\n\n-   `log_lik` includes both person information and item information in factor analysis and IRT\n\n-   `log_lik` must be a vector in Stan\n\n-   Thus, the length of log-likelihood must be a vector of length N $\\times$ J\n\nTo conduct posterior predictive model checking, we need to generate simulation data sets: `Y_rep`\n\n-   `Y_rep` can be generated using `normal_rng` and posterior draws of parameters\n\n-   `Item_Mean_rep` were generated to compared to observed item means\n\n------------------------------------------------------------------------\n\n### Model Estimation\n\nHere, my MCMC estimation is set to:\n\n::: nonincremental\n1.  Four MCMC chains that are running parallel\n2.  A seed as 1234 for replication\n3.  The warmup iteration is 1000 and the sampling iteration is 2000. Thus, the total iteration is 3000.\n4.  Since we have 4 chains, the total iteration for summary statistics is 12000 iterations.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_cfa_twofactor <- cmdstan_model(here::here(\"posts\", \"2024-01-12-syllabus-adv-multivariate-esrm-6553\", \"Lecture06\", \"Code\", \"simulation_loc.stan\"))\nfit_cfa_twofactor <- mod_cfa_twofactor$sample(\n  data = data_list,\n  seed = 1234,\n  chains = 4,\n  parallel_chains = 4, \n  iter_sampling = 2000,\n  iter_warmup = 1000\n)\n```\n:::\n\n\n### MCMC Result \\> Model diagnostic \\> PPMC\n\n\n::: {.cell}\n\n```{.r .cell-code}\nItem_Mean_rep_mat <- fit_cfa_twofactor$draws(\"Item_Mean_rep\", format = 'matrix')\nItem_Mean_obs <- colMeans(Y)\nPPP <- rep(NA, J)\nfor (item in 1:J) {\n  PPP[item] <- mean(Item_Mean_rep_mat[, item] > Item_Mean_obs[item])\n}\ndata.frame(\n  Item = factor(1:J, levels = 1:J),\n  PPP = PPP\n) |> \n  ggplot() +\n  geom_col(aes(x = Item, y = PPP)) + \n  geom_hline(aes(yintercept = .5), col = 'red', size = 1.3) + \n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](Lecture06_files/figure-revealjs/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\nAll items have PPP of item mean close to 0.5, suggesting great model-data fitting.\n\n------------------------------------------------------------------------\n\n### MCMC Result \\> Model diagnostic \\> LOO\n\nWe firt examined the max/mean PSRF (rhat) for convergence. This is also called Gelman and Rubin diagnosis. The maximum RSRF is 1.03 suggesting MCMC estimation converged.\n\nThen, we examined the LOO with PSIS. According to Pareto K diagnostic, most log-likelihood estimation suggests good reliability.\n\nQuestion: Why we have 8000 $\\times$ 6000 log-likelihood elements? hints: our information in data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_twofactor$summary(\n  variables = NULL,\n  \"rhat\"\n) |> \n summarise(mean_rhat = mean(rhat, na.rm = T),\n           max_rhat = max(rhat, na.rm = T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  mean_rhat max_rhat\n      <dbl>    <dbl>\n1      1.00     1.02\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nloo_res <- fit_cfa_twofactor$loo(variables = 'log_lik', save_psis = TRUE, cores = 2)\nprint(loo_res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nComputed from 8000 by 6000 log-likelihood matrix\n\n         Estimate    SE\nelpd_loo   4075.9  54.4\np_loo      1843.6  29.4\nlooic     -8151.9 108.8\n------\nMonte Carlo SE of elpd_loo is NA.\n\nPareto k diagnostic values:\n                         Count Pct.    Min. n_eff\n(-Inf, 0.5]   (good)     3852  64.2%   560       \n (0.5, 0.7]   (ok)       1597  26.6%   114       \n   (0.7, 1]   (bad)       530   8.8%   17        \n   (1, Inf)   (very bad)   21   0.4%   10        \nSee help('pareto-k-diagnostic') for details.\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### MCMC Results \\> Estimation \\> Factor Loadings\n\n::: columns\n::: {.column width=\"50%\"}\nBenchmark model using `lavaan`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# lavaan\nmod <- \"\nF1 =~ I1 + I2 + I3\nF2 =~ I4 + I5 + I6\n\"\ndat <- as.data.frame(Y)\ncolnames(dat) <- paste0('I', 1:6)\nfit <- cfa(mod, data = dat, std.lv = TRUE)\nlavaan::parameterestimates(fit) |> filter(op == \"=~\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lhs op rhs   est    se      z pvalue ci.lower ci.upper\n1  F1 =~  I1 0.724 0.021 34.229      0    0.682    0.765\n2  F1 =~  I2 0.521 0.017 31.478      0    0.489    0.554\n3  F1 =~  I3 0.321 0.013 25.484      0    0.296    0.345\n4  F2 =~  I4 0.666 0.020 33.504      0    0.627    0.705\n5  F2 =~  I5 0.487 0.016 30.775      0    0.456    0.518\n6  F2 =~  I6 0.306 0.013 24.022      0    0.281    0.331\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nModel 1 using `Stan`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_twofactor$summary(\"lambda\") |> select(variable,mean, median, sd, q5, q95)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  variable   mean median      sd    q5   q95\n  <chr>     <dbl>  <dbl>   <dbl> <dbl> <dbl>\n1 lambda[1] 0.723  0.723 0.0166  0.696 0.751\n2 lambda[2] 0.517  0.517 0.0120  0.497 0.537\n3 lambda[3] 0.311  0.311 0.00764 0.299 0.324\n4 lambda[4] 0.675  0.674 0.0159  0.649 0.701\n5 lambda[5] 0.484  0.484 0.0115  0.465 0.503\n6 lambda[6] 0.294  0.294 0.00747 0.282 0.306\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_twofactor$summary(\"lambda\", \\(x) quantile(x, c(.025, .975)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  variable  `2.5%` `97.5%`\n  <chr>      <dbl>   <dbl>\n1 lambda[1]  0.691   0.756\n2 lambda[2]  0.494   0.541\n3 lambda[3]  0.296   0.327\n4 lambda[4]  0.645   0.706\n5 lambda[5]  0.462   0.506\n6 lambda[6]  0.280   0.309\n```\n\n\n:::\n:::\n\n:::\n:::\n\nWe can easily notice how consistent between estimates of `lavaan` with `Stan` :\n\n::: nonincremental\n1.  `est` in `lavaan` corresponds to `mean` or `median` in `stan` . Their difference is around .001 - .002.\n2.  `se` in `lavaan` corresponds to `sd` in `stan`\n3.  `ci.lower` and `ci.upper` in lavaan is for 95% confidence interval, so they have larger range than `q5` and `q95` in Stan, which is for 90% Credible Interval\n4.  90% CI is the default setting, but we can calculate Bayesian 95% Credible Interval using `$summary()`\n:::\n\n------------------------------------------------------------------------\n\n### MCMC Results \\> Visualization \\> Factor Loadings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::color_scheme_set(\"viridis\")\nbayesplot::mcmc_trace(fit_cfa_twofactor$draws(), regex_pars = \"lambda\")\n```\n\n::: {.cell-output-display}\n![](Lecture06_files/figure-revealjs/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### MCMC Results \\> Estimation \\> Factor Correlation\n\nThe factor correlation (Psi = .3) is represented by the non-diagonal elements of factor correlation.\n\nThere are two ways to check estimation of factor correlation:\n\n-   Since we use LKJ sampling with `L` Cholesky factor, recall that `L` is lower triangle of factor correlation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_twofactor$summary(\"L[2,1]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  variable  mean median     sd    mad    q5   q95  rhat ess_bulk ess_tail\n  <chr>    <dbl>  <dbl>  <dbl>  <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>\n1 L[2,1]   0.318  0.318 0.0285 0.0282 0.271 0.364  1.00    2365.    4245.\n```\n\n\n:::\n:::\n\n\n-   We can also look at the elements of factor correlation matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_twofactor$summary(c(\"corrTheta[1,2]\", \"corrTheta[2,1]\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 10\n  variable        mean median     sd    mad    q5   q95  rhat ess_bulk ess_tail\n  <chr>          <dbl>  <dbl>  <dbl>  <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>\n1 corrTheta[1,2] 0.318  0.318 0.0285 0.0282 0.271 0.364  1.00    2365.    4245.\n2 corrTheta[2,1] 0.318  0.318 0.0285 0.0282 0.271 0.364  1.00    2365.    4245.\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### MCMC Results \\> Visualization \\> Factor Correlation\n\n-   We can also visual inspect trace plots of MCMC draws of `L`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::mcmc_trace(fit_cfa_twofactor$draws(\"L[2,1]\"))\n```\n\n::: {.cell-output-display}\n![](Lecture06_files/figure-revealjs/unnamed-chunk-25-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### MCMC Results \\> Estimation \\> Item Intercepts\n\nItem intercepts are set to .1. Let's see what Bayesian model recovers the true values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_twofactor$summary(\"mu\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 10\n  variable   mean median      sd     mad     q5   q95  rhat ess_bulk ess_tail\n  <chr>     <dbl>  <dbl>   <dbl>   <dbl>  <dbl> <dbl> <dbl>    <dbl>    <dbl>\n1 mu[1]    0.107  0.107  0.0218  0.0220  0.0717 0.144  1.01     154.     384.\n2 mu[2]    0.107  0.107  0.0157  0.0156  0.0814 0.133  1.01     158.     371.\n3 mu[3]    0.101  0.101  0.00965 0.00967 0.0858 0.117  1.01     163.     403.\n4 mu[4]    0.0818 0.0811 0.0221  0.0223  0.0471 0.119  1.02     130.     285.\n5 mu[5]    0.0948 0.0945 0.0160  0.0160  0.0695 0.122  1.02     131.     279.\n6 mu[6]    0.0979 0.0977 0.0101  0.0103  0.0817 0.115  1.02     137.     315.\n```\n\n\n:::\n:::\n\n\nWe notices item 4 is little off with true values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::mcmc_trace(fit_cfa_twofactor$draws(\"mu\"))\n```\n\n::: {.cell-output-display}\n![](Lecture06_files/figure-revealjs/unnamed-chunk-27-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### MCMC Results \\> Estimation \\> **Residual variances**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_twofactor$summary(\"sigma\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 10\n  variable   mean median      sd     mad     q5   q95  rhat ess_bulk ess_tail\n  <chr>     <dbl>  <dbl>   <dbl>   <dbl>  <dbl> <dbl> <dbl>    <dbl>    <dbl>\n1 sigma[1] 0.108  0.108  0.00676 0.00669 0.0966 0.119  1.01     983.    1474.\n2 sigma[2] 0.0993 0.0992 0.00415 0.00409 0.0924 0.106  1.00    1607.    3020.\n3 sigma[3] 0.0960 0.0960 0.00245 0.00243 0.0920 0.100  1.00    8926.    6999.\n4 sigma[4] 0.0987 0.0989 0.00708 0.00714 0.0868 0.110  1.00     802.    1229.\n5 sigma[5] 0.0964 0.0964 0.00406 0.00406 0.0897 0.103  1.00    1515.    3460.\n6 sigma[6] 0.0999 0.0998 0.00257 0.00260 0.0958 0.104  1.00    8005.    6296.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::mcmc_trace(fit_cfa_twofactor$draws(\"sigma\"))\n```\n\n::: {.cell-output-display}\n![](Lecture06_files/figure-revealjs/unnamed-chunk-29-1.png){width=960}\n:::\n:::\n\n\n## Simulation Study 2\n\n\n::: {.cell}\n\n:::\n\n\n::: nonincremental\n-   To illustrate how to model a more complex CFA with cross-loadings, let's generate a new simulation data with test length 7 and two latent variables\n-   The mean structure of model is like this, each latent variable was measured by 4 items. The other parameters are as same as Model 1.\n:::\n\n![Mean Structure of Model 2](simulation_model2.png)\n\n------------------------------------------------------------------------\n\n### Strategies for Model 2\n\nThe general idea is that we assign a uninformative prior distribution for \"main\" factor loadings, and assign informative \"close-to-zero\" prior distribution for \"zero\" factor loadings:\n\n![](simulation_priorsetting.png)\n\n------------------------------------------------------------------------\n\n### Strategies for Model 2 (Cont.)\n\n::: columns\n::: {.column width=\"50%\"}\n-   Have a more detailed location matrix for factor loading matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(Lambda2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   V1  V2\n1 0.7 0.0\n2 0.5 0.0\n3 0.3 0.0\n4 0.5 0.5\n5 0.0 0.7\n6 0.0 0.5\n7 0.0 0.3\n```\n\n\n:::\n:::\n\n\n-   We can transform the information of factor loading into:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Transform Q to location index\nloc2 <- Q2 |>\n  as.data.frame() |>\n  rename(`1` = V1, `2` = V2) |> \n  rownames_to_column(\"Item\") |>\n  pivot_longer(c(`1`, `2`), names_to = \"Theta\", values_to = \"q\") |> \n  mutate(across(Item:q, as.numeric)) |> \n  mutate(q = -q + 2) |> \n  as.matrix()\nas.data.frame(loc2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Item Theta q\n1     1     1 1\n2     1     2 2\n3     2     1 1\n4     2     2 2\n5     3     1 1\n6     3     2 2\n7     4     1 1\n8     4     2 1\n9     5     1 2\n10    5     2 1\n11    6     1 2\n12    6     2 1\n13    7     1 2\n14    7     2 1\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n-   Where `Item` represents the index of item a factor loading belongs to, and `Theta` represents the index of latent variables a factor loading belongs to.\n\n-   In Stan's data block, we denote `Item` of location matrix as `jj` and `Theta` as `kk` . `q` represents two types of prior distributions for factor loadings.\n\n\n::: {.cell filename='simulation_exp2.stan' output.var='display'}\n\n```{.stan .cell-code}\ndata {\n  ...\n  int<lower=0> R; // number of rows in location matrix\n  array[R] int<lower=0>jj;\n  array[R] int<lower=0>kk;\n  array[R] int<lower=0>q;\n  ...\n}\n```\n:::\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Data Structure and Data Block\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell filename='Lecture06.R'}\n\n```{.r .cell-code}\ndata_list2 <- list(\n  N = 1000, # number of subjects/observations\n  J = J2, # number of items\n  K = 2, # number of latent variables,\n  Y = Y2,\n  Q = Q2,\n  # location of lambda\n  R = nrow(loc2),\n  jj = loc2[,1],\n  kk = loc2[,2],\n  q = loc2[,3],\n  #hyperparameter\n  meanSigma = .1,\n  scaleSigma = 1,\n  meanMu = rep(0, J2),\n  covMu = diag(10, J2),\n  meanTheta = rep(0, 2),\n  corrTheta = matrix(c(1, .3, .3, 1), 2, 2, byrow = T)\n)\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell filename='simulation_exp2.stan' output.var='display'}\n\n```{.stan .cell-code}\ndata {\n  int<lower=0> N; // number of observations\n  int<lower=0> J; // number of items\n  int<lower=0> K; // number of latent variables\n  matrix[N, J] Y; // item responses\n  \n  int<lower=0> R; // number of rows in location matrix\n  array[R] int<lower=0>jj;\n  array[R] int<lower=0>kk;\n  array[R] int<lower=0>q;\n  \n  //hyperparameter\n  real<lower=0> meanSigma;\n  real<lower=0> scaleSigma;\n  vector[J] meanMu;\n  matrix[J, J] covMu;      // prior covariance matrix for coefficients\n  vector[K] meanTheta;\n  matrix[K, K] corrTheta;\n  \n}\n```\n:::\n\n:::\n:::\n\nNote that for the simplicity of estimation, I specified the factor correlation matrix as fixed. If you are interested in estimating factor correlation, you can refer to the previous model using LKJ sampling.\n\n------------------------------------------------------------------------\n\n### Parameters block\n\n\n::: {.cell filename='simulation_exp2.stan' output.var='display'}\n\n```{.stan .cell-code}\nparameters {\n  vector<lower=0,upper=1>[J] mu;\n  matrix<lower=0>[J, K] lambda;\n  vector<lower=0,upper=1>[J] sigma; // the unique residual standard deviation for each item\n  matrix[N, K] theta;                // the latent variables (one for each person)\n  //matrix[K, K] corrTheta; // not use corrmatrix to avoid duplicancy of validation\n}\n\n```\n:::\n\n\nFor `parameters` block, the only difference is we specify `lambda` as a matrix with J $\\times$ K, which is 7 $\\times$ 2 in our case.\n\n------------------------------------------------------------------------\n\n### Model block\n\nAs you can see, in `Model` block, we need to use if_else in Stan to specify factor loadings in different locations\n\n::: nonincremental\n-   For type 1 (green), we specify a uninformative normal distribution\n-   For type 2 (red), we specify a informative shrinkage priors.\n-   For univariate residual, we can simply use `cauchy` or `exponential` prior\n-   The item response function estimate each item response using $\\mu+ \\Lambda * \\Theta$ as kernal and $\\sigma$ as variation\n:::\n\n\n::: {.cell filename='simulation_exp2.stan' output.var='display'}\n\n```{.stan .cell-code}\nmodel {\n  mu ~ multi_normal(meanMu, covMu);\n  // specify lambda's regulation\n  for (r in 1:R) {\n    if (q[r] == 1){\n      lambda[jj[r], kk[r]] ~ normal(0, 10);\n    }else{// student_t(nu, mu, sigma)\n      lambda[jj[r], kk[r]] ~ student_t(1, 0, 0.01);\n    }\n  }\n  //corrTheta ~ lkj_corr(eta);\n  for (i in 1:N) {\n    theta[i,] ~ multi_normal(meanTheta, corrTheta);\n  }\n  for (j in 1:J) {\n    sigma[j] ~ cauchy(meanSigma, scaleSigma);                   // Prior for unique standard deviations\n    Y[,j] ~ normal(mu[j]+to_row_vector(lambda[j,])*theta', sigma[j]);\n  }\n}\n```\n:::\n\n\n------------------------------------------------------------------------\n\n### Model Result \\> R-hat\n\nWe set up the MCMC as follows:\n\n::: nonincremental\n-   3000 warmups + 3000 samplings = 6000 iterations\n-   Total execution time: 202.7 seconds for my computers but it takes 20 minutes or more if I specify inproper priors\n-   4 chains\n-   R hat is acceptable suggesting convergence\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_exp2 <- mod_cfa_exp2$sample(\n  data = data_list2,\n  seed = 1234,\n  chains = 4,\n  parallel_chains = 4, \n  iter_sampling = 3000,\n  iter_warmup = 3000\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_exp2$summary(\n  variables = NULL,\n  \"rhat\"\n) |> \n summarise(mean_rhat = mean(rhat, na.rm = T),\n           max_rhat = max(rhat, na.rm = T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  mean_rhat max_rhat\n      <dbl>    <dbl>\n1      1.00     1.04\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### MCMC Results \\> Estimation \\> Factor Loadings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_cfa_exp2$summary('lambda') |> select(variable, mean, median, sd, q5, q95)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14 × 6\n   variable       mean  median      sd       q5    q95\n   <chr>         <dbl>   <dbl>   <dbl>    <dbl>  <dbl>\n 1 lambda[1,1] 0.713   0.713   0.0157  0.688    0.739 \n 2 lambda[2,1] 0.508   0.508   0.0114  0.490    0.527 \n 3 lambda[3,1] 0.305   0.305   0.00723 0.293    0.317 \n 4 lambda[4,1] 0.514   0.514   0.0125  0.494    0.535 \n 5 lambda[5,1] 0.00723 0.00576 0.00602 0.000542 0.0192\n 6 lambda[6,1] 0.00792 0.00714 0.00505 0.00123  0.0174\n 7 lambda[7,1] 0.00475 0.00420 0.00321 0.000561 0.0107\n 8 lambda[1,2] 0.00634 0.00472 0.00601 0.000422 0.0181\n 9 lambda[2,2] 0.00806 0.00722 0.00532 0.00124  0.0176\n10 lambda[3,2] 0.00633 0.00589 0.00376 0.00106  0.0131\n11 lambda[4,2] 0.491   0.491   0.0120  0.473    0.511 \n12 lambda[5,2] 0.680   0.680   0.0147  0.657    0.705 \n13 lambda[6,2] 0.482   0.482   0.0107  0.465    0.500 \n14 lambda[7,2] 0.285   0.285   0.00676 0.274    0.296 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nLambda2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]  0.7  0.0\n[2,]  0.5  0.0\n[3,]  0.3  0.0\n[4,]  0.5  0.5\n[5,]  0.0  0.7\n[6,]  0.0  0.5\n[7,]  0.0  0.3\n```\n\n\n:::\n:::\n\n\n## Wrapping up\n\nWe simulated two models: one is 2-factor model without cross-loadings; another is 2-factor model with cross-loadings.\n\nIn real setting, the Bayesian modeling could be challenging because\n\n::: nonincremental\n-   Prior distributions are unsure\n\n-   Bad prior may leads to unconverge; So try multiple priors\n\n    -   Good priors will have nice converge very early (i.e, 500 or 1000 samples)\n\n-   MCMC sampling is computationally intensive, and you may not sure how many iterations are enough\n\n-   Hard to come up with a strategy of model building\n\n    -   For example, \"location matrix and different priors\" is a strategy I prefer\n\n    -   It may not works for any problems for cross-loadings\n\n-   You may try `blavaan` or other wrap-up package for Bayesian CFA, it saves some time for model building\n\n    -   But you have no idea how they set up MCMC\n:::\n\nAll of these topics will be with us when we start model complicated models in our future lecture.\n\n------------------------------------------------------------------------\n\n## Next Class\n\n1.  More strategies about measurement models with Stan\n\n## Other materials\n\n1.  [Jonathan Templin's Website](https://jonathantemplin.github.io/Bayesian-Psychometric-Modeling-Course-Fall2022/lectures/lecture04b/04b_Modeling_Observed_Data)\n2.  [Winston-Salem's Website](https://medewitt.github.io/resources/stan_cfa.html)\n3.  [Rick Farouni's Website](https://rfarouni.github.io/assets/projects/BayesianFactorAnalysis/BayesianFactorAnalysis.html)\n\n## Reference\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}