{
  "hash": "9ac0c41179d0935b77a7c41f5519ad72",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 04\"\nsubtitle: \"Linear Regression Model with Stan II\"\nauthor: \"Jihong Zhang\"\ninstitute: \"Educational Statistics and Research Methods\"\ntitle-slide-attributes:\n  data-background-image: ../Images/title_image.png\n  data-background-size: contain\n  data-background-opacity: \"0.9\"\nexecute: \n  echo: true\nformat: \n  revealjs:\n    logo: ../Images/UA_Logo_Horizontal.png\n    incremental: true  # choose \"false \"if want to show all together\n    theme: [serif, ../pp.scss]\n    footer:  <https://jihongzhang.org/posts/2024-01-12-syllabus-adv-multivariate-esrm-6553>\n    transition: slide\n    background-transition: fade\n    slide-number: true\n    chalkboard: true\n    number-sections: false\n    code-line-numbers: true\n    code-annotations: hover\n    code-copy: true\n    highlight-style: arrow\n    code-block-border-left: true\n    code-block-background: \"#b22222\"\n---\n\n\n## Today's Lecture Objectives\n\n1.  Making Stan Syntax Shorter\n\n2.  Computing Functions of Model Parameters\n\n    **Download R file [DietDataExample2.R]{.underline}**\n\n## In previous class...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- read.csv(here::here(\"posts\", \"2024-01-12-syllabus-adv-multivariate-esrm-6553\", \"Lecture03\", \"Code\", \"DietData.csv\"))\ndat$DietGroup <- factor(dat$DietGroup, levels = 1:3)\ndat$HeightIN60 <- dat$HeightIN - 60\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Respondent DietGroup HeightIN WeightLB HeightIN60\n1          1         1       56      140         -4\n2          2         1       60      155          0\n3          3         1       64      143          4\n4          4         1       68      161          8\n5          5         1       72      139         12\n6          6         1       54      159         -6\n```\n\n\n:::\n:::\n\n\n1.  Introduce the empty model\n2.  Example: Post-Diet Weights\n    -   WeightLB (*Dependent Variable*): The respondents' weight in pounds\n    -   HeightIN: The respondents' height in inches\n    -   DietGroup: 1, 2, 3 representing the group to which a respondent was assigned\n3.  The empty model has two parameters to be estimated: (1) $\\beta_0$, (2) $\\sigma_e$\n4.  The posterior mean/median/mode of $\\beta_0$ should be mean of WeightLB\n5.  The posterior mean/median/mode of $\\sigma_e$ should be sd of WeightLB\n\n## Making `Stan` Code Short\n\nThe Stan syntax from our previous model was lengthy:\n\n-   A declared variable for each parameter\n\n-   The linear combination of coefficients multiplying predictors\n\nStan has built-in features to shorten syntax:\n\n-   Matrices/Vectors\n\n-   Matrix products\n\n-   Multivariate distribution (initially for prior distributions)\n\n------------------------------------------------------------------------\n\n## Linear Models without Matrices\n\nThe linear model from our example was:\n\n$$\n\\text{WeightLB}_p = \\beta_0 + \\beta_1 \\text{HeightIN}_p + \\beta_2 \\text{Group2}_p + \\beta_3\\text{Group3}_p \\\\ \n+\\beta_4 \\text{HeightIN}_p\\text{Group2}_p \\\\\n+\\beta_5 \\text{HeightIN}_p\\text{Group3}_p \\\\\n+ e_p\n$$\n\nwith:\n\n-   $\\text{Group2}_p$ the binary indicator of person $p$ being in group 2\n\n-   $\\text{Group}3_p$ the binary indicator of person $p$ being in group 3\n\n-   $e_p \\sim N(0, \\sigma_e)$\n\n------------------------------------------------------------------------\n\n### Path Diagram of Model\n\n\n```{mermaid}\n%%| echo: false\n%%| label: fig-diagram\ngraph LR;\n  HeightIN60 --> WeightLB;\n  DietGroup2 --> WeightLB;\n  DietGroup3 --> WeightLB;\n  HeightIN60xDietGroup2 --> WeightLB;\n  HeightIN60xDietGroup3 --> WeightLB;\n```\n\n\n------------------------------------------------------------------------\n\n## Linear Models with Matrices\n\n::: columns\n::: {.column width=\"50%\"}\nModel (predictor) matrix with the size 30 (rows) $\\times$ 6 (columns)\n\n$$\n\\mathbf{X} = \\begin{bmatrix}1 & -4 & 0 & 0 & 0 & 0\\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 12 & 0 & 1 & 0 & 12 \\end{bmatrix}\n$$\n:::\n\n::: {.column width=\"50%\"}\nCoefficients vectors with the size 6 (rows) $\\times$ 1 (column):\n\n$$\n\\mathbf{\\beta} =\n\\begin{bmatrix}\n\\beta_0 \\\\\n\\beta_1 \\\\\n\\beta_2 \\\\\n\\beta_3 \\\\\n\\beta_4 \\\\\n\\beta_5 \\\\\n\\end{bmatrix}\n$$\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFullModelFormula = as.formula(\"WeightLB ~ HeightIN60 + DietGroup + HeightIN60*DietGroup\")\nmodel.matrix(FullModelFormula, data = dat) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept) HeightIN60 DietGroup2 DietGroup3 HeightIN60:DietGroup2\n1           1         -4          0          0                     0\n2           1          0          0          0                     0\n3           1          4          0          0                     0\n4           1          8          0          0                     0\n5           1         12          0          0                     0\n6           1         -6          0          0                     0\n  HeightIN60:DietGroup3\n1                     0\n2                     0\n3                     0\n4                     0\n5                     0\n6                     0\n```\n\n\n:::\n:::\n\n\n## Linear Models with Matrices\n\nWe then rewrite the equation from\n\n$$\n\\text{WeightLB}_p = \\beta_0 + \\beta_1 \\text{HeightIN}_p + \\beta_2 \\text{Group2}_p + \\beta_3\\text{Group3}_p \\\\ \n+\\beta_4 \\text{HeightIN}_p\\text{Group2}_p \\\\\n+\\beta_5 \\text{HeightIN}_p\\text{Group3}_p \\\\\n+ e_p\n$$\n\nto:\n\n$$\n\\mathbf{WeightLB} = \\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{e} \n$$\n\nWhere:\n\n-   $\\mathbf{WeightLB}$ is the vector of outcome (N $\\times$ 1)\n\n-   $\\mathbf{X}$ is the model (predictor) matrix (N $\\times$ P for P - 1 predictors)\n\n-   $\\boldsymbol{\\beta}$ is the coefficients vector (P $\\times$ 1)\n\n-   $\\mathbf{e}$ is the vector for residuals (N $\\times$ 1)\n\n## Example: Predicted Values\n\nSimilar to Monte Carlo Simulation, given $P$ and $\\boldsymbol{\\beta}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nP = 6\nbeta = matrix(data = runif(n = 6, min = 0, max = 10), nrow = P, ncol = 1)\nbeta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         [,1]\n[1,] 1.137034\n[2,] 6.222994\n[3,] 6.092747\n[4,] 6.233794\n[5,] 8.609154\n[6,] 6.403106\n```\n\n\n:::\n\n```{.r .cell-code}\nX = model.matrix(FullModelFormula, data = dat)\nX %*% beta \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         [,1]\n1  -23.754942\n2    1.137034\n3   26.029010\n4   50.920986\n5   75.812963\n6  -36.200930\n7   13.583022\n8   32.252004\n9   32.252004\n10  63.366975\n11 -52.098810\n12   7.229781\n13  66.558373\n14 125.886965\n15 185.215556\n16 -81.763106\n17  36.894077\n18  81.390521\n19  81.390521\n20 155.551260\n21 -68.385772\n22 -17.881372\n23  32.623029\n24  83.127429\n25 133.631830\n26 -93.637972\n27  -5.255272\n28  57.875229\n29  70.501329\n30 158.884030\n```\n\n\n:::\n:::\n\n\n## Vectorize prior distributions\n\nPreviously, we defined a normal distribution for each regression coefficient $$\n\\beta_0 \\sim normal(0, 1) \\\\\n\\vdots \\\\\n\\beta_p \\sim normal(0, 1)\n$$\n\n-   They are all univariate normal distribution\n-   Issue: Each parameter had a prior that was independent of the other parameter; then the correlation between betas is low and cannot be changed.\n\nFor example, the code shows two betas with univariate normal distribution have low correlation (r = -0.025)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbeta0 = rnorm(100, 0, 1)\nbeta1 = rnorm(100, 0, 1)\ncor(beta0, beta1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.02538285\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Vectorize prior distributions (Cont.)\n\nWhen combining all parameters into a vector, a natural extension is a multivariate normal distribution, so that the betas have a pre-defined correlation strength\n\n- The syntax shows the two betas generated by the multivariate normal distribution with correlation of .5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nsigma_of_betas = matrix(c(1, 0.5, 0.5, 1), ncol = 2)\nbetas = mvtnorm::rmvnorm(100, mean = c(0, 0), sigma = sigma_of_betas)\nbeta0 = betas[,1]\nbeta1 = betas[,2]\ncor(beta0, beta1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5453899\n```\n\n\n:::\n:::\n\nBack to the `stan` code, we need to specify:\n\n- Mean vector of betas (`meanBeta`; size P $\\times$ 1)\n  - Put all prior means for those coefficients into a vector\n- Covariance matrix for betas (`covBeta`; size P $\\times$ P) \n  - Put all prior variances into the diagonal; zeros for off diagonal; 'cause we are not sure the potential correlation between betas\n\n\n## Syntax Changes: Data Section\n\n**Old syntax without matrix:**\n\n\n::: {.cell output.var='display'}\n\n```{.stan .cell-code}\ndata{\n    int<lower=0> N;\n    vector[N] weightLB;\n    vector[N] height60IN;\n    vector[N] group2;\n    vector[N] group3;\n    vector[N] heightXgroup2;\n    vector[N] heightXgroup3;\n}\n```\n:::\n\n\n**New syntax with matrix:**\n\n\n::: {.cell output.var='display'}\n\n```{.stan .cell-code}\ndata{\n  int<lower=0> N;         // number of observations\n  int<lower=0> P;         // number of predictors (plus column for intercept)\n  matrix[N, P] X;         // model.matrix() from R \n  vector[N] y;            // outcome\n  \n  vector[P] meanBeta;     // hyperparameter: prior mean vector for coefficients\n  matrix[P, P] covBeta;   // hyperparameter: prior covariance matrix for coefficients\n  \n  real sigmaRate;         // hyperparameter: prior rate parameter for residual standard deviation\n}\n```\n:::\n\n\n\n## Syntax Changes: Parameters Section\n\n**Old syntax without matrix:**\n\n\n::: {.cell output.var='display'}\n\n```{.stan .cell-code}\nparameters {\n  real beta0;\n  real betaHeight;\n  real betaGroup2;\n  real betaGroup3;\n  real betaHxG2;\n  real betaHxG3;\n  real<lower=0> sigma;\n}\n```\n:::\n\n\n**New syntax with matrix:**\n\n\n::: {.cell output.var='display'}\n\n```{.stan .cell-code}\nparameters {\n  vector[P] beta;         // vector of coefficients for Beta\n  real<lower=0> sigma;    // residual standard deviation\n}\n```\n:::\n\n\n## Syntax Changes: Prior Distributions Definition\n\n**Old syntax without matrix:**\n\n\n::: {.cell output.var='display'}\n\n```{.stan .cell-code  code-line-numbers=\"2-8\"}\nmodel {\n  beta0 ~ normal(0,1);\n  betaHeight ~ normal(0,1);\n  betaGroup2 ~ normal(0,1);\n  betaGroup3 ~ normal(0,1);\n  betaHxG2 ~ normal(0,1);\n  betaHxG3 ~ normal(0,1);\n  sigma ~ exponential(.1); // prior for sigma\n  weightLB ~ normal(\n    beta0 + betaHeight * height60IN + betaGroup2 * group2 + \n    betaGroup3 * group3 + betaHxG2 *heightXgroup2 +\n    betaHxG3 * heightXgroup3, sigma);\n}\n```\n:::\n\n\n**New syntax with matrix:**\n\n- `multi_normal()` is the multivariate normal sampling in Stan, similar to `rmvnorm()` in R\n- `exponential()` is the exponential distribution sampling in Stan, similar to `rexp()` in R\n\n\n::: {.cell output.var='display'}\n\n```{.stan .cell-code}\nmodel {\n  beta ~ multi_normal(meanBeta, covBeta); // prior for coefficients\n  sigma ~ exponential(sigmaRate);         // prior for sigma\n  y ~ normal(X*beta, sigma);              // linear model\n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Lecture04_files/figure-revealjs/unnamed-chunk-13-1.png){width=960}\n:::\n:::\n\n\n\n## Wrapping up\n\n1.  MCMC algorithm includes the Bayes' theorm and sampling approaches\n2.  Stan syntax: need `.stan` storing the model information and `.r` storing R codes to run and summarize the model\n3.  `cmdstanr` will compile the `.stan` and run the MCMC\n4.  To run MCMC, you need to specify number of chains, interations, burnins. You also translate data information into a data list\n5.  After you finish estimation, check the convergence using $\\hat{R}$ and visual inspection of traceplot\n",
    "supporting": [
      "Lecture04_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}